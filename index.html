<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="NiaTranslator: Novel & Fanfiction Translation Tool" />
  <title>NiaTranslator - Novel & Fanfiction Tool</title>

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.gstatic.com" />
  <link
    href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600&display=swap"
    rel="stylesheet"
  />

  <style>
    /* ======== RESET & BASE ======== */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: 'Open Sans', Arial, sans-serif;
      background: #f4f5f7;
      color: #333;
      line-height: 1.5;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    /* ======== HEADER ======== */
    header {
      background: #3f51b5;
      color: #fff;
      padding: 1rem 2rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 1.5rem;
    }
    header h1 {
      margin: 0;
      font-weight: 600;
      font-size: 1.8rem;
    }

    /* ======== CONTAINER ======== */
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 1rem;
    }

    /* ======== SECTIONS ======== */
    .section {
      background: #fff;
      padding: 1.5rem;
      border-radius: 6px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
      position: relative;
      margin-bottom: 2rem;
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    .section-title {
      text-align: center;
      font-size: 1.4rem;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }
    .subtitle {
      color: #666;
      font-size: 0.9rem;
      text-align: center;
      margin-bottom: 1rem;
    }

    /* ======== FORMS & INPUTS ======== */
    label {
      display: block;
      margin-bottom: 0.25rem;
      font-weight: 600;
    }
    input[type="text"],
    select,
    textarea {
      width: 100%;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 0.5rem;
      font-size: 0.95rem;
      background-color: #fff;
      color: #333;
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    input[type="text"]:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: #3f51b5;
      box-shadow: 0 0 0 2px rgba(63,81,181,0.15);
    }
    textarea {
      resize: vertical;
      min-height: 100px;
    }

    /* ======== BUTTONS ======== */
    button {
      display: inline-block;
      background-color: #3f51b5;
      color: #fff;
      border: none;
      border-radius: 5px;
      padding: 0.6rem 1rem;
      font-size: 0.95rem;
      cursor: pointer;
      transition: background-color 0.2s ease, transform 0.1s ease;
    }
    button:hover {
      background-color: #2c3996;
    }
    button:active {
      transform: scale(0.98);
    }
    .secondary {
      background-color: #757575;
    }
    .secondary:hover {
      background-color: #5e5e5e;
    }

    /* ======== GRID ======== */
    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 2rem;
    }
    @media (max-width: 900px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }

    /* ======== API KEY SECTION ======== */
    #apiKeyContainer {
      max-width: 600px;
      margin: 0 auto;
      margin-bottom: 2rem;
      text-align: center;
    }
    #apiKeyInput {
      width: 70%;
      margin-right: 0.5rem;
    }
    #apiKeyStatus {
      margin-top: 0.5rem;
      font-weight: 600;
    }

    /* ======== TRANSLATION SECTION ======== */
    #translationSection .section-title {
      margin-top: 0;
    }
    #charCount {
      font-size: 0.85rem;
      color: #999;
      margin-bottom: 0.5rem;
    }
    #loadingIndicator {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #666;
    }
    .progress-bar-container {
      width: 100%;
      background-color: #e9ecef;
      height: 6px;
      border-radius: 4px;
      overflow: hidden;
      display: none; 
      position: absolute;
      top: 0;
      left: 0;
      transition: background-color 0.3s ease;
    }
    .progress-bar {
      height: 100%;
      background-color: #3f51b5;
      width: 0%;
      transition: width 0.2s ease;
    }

    /* ======== GLOSSARY SECTION ======== */
    #glossarySection .section-title {
      margin-top: 0;
    }
    #glossaryPanel {
      max-height: 2000px;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    .collapsed {
      max-height: 0 !important;
      padding: 0 !important;
      margin: 0 !important;
    }

    .glossary-list {
      max-height: 320px;
      overflow-y: auto;
      margin-top: 1rem;
      border: 1px solid #eee;
      border-radius: 4px;
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    .glossary-list table {
      width: 100%;
      border-collapse: collapse;
    }
    .glossary-list th,
    .glossary-list td {
      text-align: left;
      padding: 0.75rem;
      border-bottom: 1px solid #eee;
    }
    .glossary-list thead {
      background: #fafafa;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    .glossary-list tbody tr:hover {
      background: #f9f9f9;
    }

    /* ======== CUSTOM NOTES SECTION ======== */
    #contextSection .section-title {
      margin-top: 0;
    }

    /* ======== DARK MODE ======== */
    .dark-mode {
      background-color: #222;
      color: #ccc;
    }
    .dark-mode header {
      background-color: #1b1b1b;
      color: #eee;
    }
    .dark-mode .section {
      background-color: #2e2e2e;
      color: #ccc;
    }
    .dark-mode button {
      background-color: #444;
      color: #eee;
    }
    .dark-mode button:hover {
      background-color: #555;
    }
    .dark-mode .secondary {
      background-color: #555;
    }
    .dark-mode .secondary:hover {
      background-color: #666;
    }
    .dark-mode input[type="text"],
    .dark-mode textarea,
    .dark-mode select {
      background-color: #333;
      border: 1px solid #555;
      color: #ccc;
    }
    .dark-mode #charCount {
      color: #aaa;
    }
    .dark-mode #loadingIndicator {
      color: #bbb;
    }
    .dark-mode .progress-bar-container {
      background-color: #333;
    }
    .dark-mode .progress-bar {
      background-color: #666;
    }
    .dark-mode .glossary-list {
      border-color: #555;
    }
    .dark-mode .glossary-list table thead {
      background-color: #333;
      color: #ccc;
    }
    .dark-mode .glossary-list tbody tr:hover {
      background-color: #3b3b3b;
    }
    .dark-mode .glossary-list td,
    .dark-mode .glossary-list th {
      border-color: #444;
    }
  </style>
</head>

<body>
  <header>
    <h1>NiaTranslator</h1>
  </header>

  <div class="container">
    <!-- ====== API KEY SETUP ====== -->
    <section class="section" id="apiKeyContainer">
      <h2 class="section-title">API Key Setup</h2>
      <p class="subtitle">Provide your OpenRouter API Key to use the translation service</p>
      <input type="text" id="apiKeyInput" placeholder="Enter your OpenRouter API Key">
      <button id="saveApiKeyButton">Save API Key</button>
      <p id="apiKeyStatus" style="color: green;"></p>
    </section>

    <!-- ====== CUSTOM NOTES SECTION ====== -->
    <section class="section" id="contextSection">
      <h2 class="section-title">Persistent Notes for Novel & Fanfiction</h2>
      <p class="subtitle">
        Enter important context for your story (e.g., "The main character is Gojo Satoru, a playful sorcerer."). 
        These notes will be added to the system prompt before translation.
      </p>
      <textarea
        id="customNotes"
        placeholder="Example: The main character is Gojo Satoru, with silver hair, witty remarks..."
      ></textarea>
      <div style="margin-top: 1rem;">
        <button id="saveNotesButton">Save Notes</button>
        <button id="clearNotesButton" class="secondary">Clear</button>
        <input type="checkbox" id="useNotesCheckbox" checked>
        <label for="useNotesCheckbox">Use Custom Notes</label>
      </div>
    </section>

    <div class="grid">
      <!-- ====== TRANSLATION SECTION ====== -->
      <section class="section" id="translationSection">
        <div class="progress-bar-container" id="progressBarContainer">
          <div class="progress-bar" id="progressBar"></div>
        </div>
        <h2 class="section-title">Translation</h2>
        <p class="subtitle">Paste your text (HTML or plain), then translate</p>
        <div id="charCount">Characters: 0 | Approx. Tokens: 0</div>
        <textarea id="inputText" placeholder="Paste text or HTML here..."></textarea>
        
        <div style="margin-bottom: 1rem; display:flex; gap:0.5rem; flex-wrap:wrap;">
          <button id="clearInputButton" class="secondary">Clear Input</button>
          <button id="preReplaceButton">Use Glossary</button>
          <button id="uploadDocxButton" class="secondary">Upload .docx</button>
          <input type="file" id="docxFileInput" accept=".docx" style="display: none;" />
        </div>

        <div style="margin-bottom:1rem; display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center;">
          <label for="targetLanguage" style="margin-bottom:0;">Target Language:</label>
          <select id="targetLanguage">
            <option value="en">English</option>
            <option value="ja">Japanese</option>
          </select>
          <button id="translateButton">Translate</button>
        </div>

        <div id="loadingIndicator" style="display:none;">Translating... Please wait.</div>
        <textarea id="translatedText" readonly placeholder="Translated text will appear here."></textarea>
        
        <div style="margin-top:1rem; display:flex; gap:0.5rem; flex-wrap:wrap;">
          <button id="clearOutputButton" class="secondary">Clear Output</button>
          <button id="exportTxtButton">Export as .txt</button>
          <button id="exportHtmlButton">Export as .html</button>
        </div>

        <div style="margin-top:1.5rem; text-align:center;">
          <input type="checkbox" id="realtimeCheckbox">
          <label for="realtimeCheckbox">Enable real-time translation (beta)</label>
        </div>
      </section>

      <!-- ====== GLOSSARY SECTION ====== -->
      <section class="section" id="glossarySection">
        <h2 class="section-title">Glossary Management</h2>
        <p class="subtitle">Manage custom terms here and pre-replace them in your text</p>
        <button id="toggleGlossaryPanel" style="position:absolute; top:1rem; right:1rem;">Hide</button>
        <div id="glossaryPanel">
          <div style="margin-bottom:1rem;">
            <button id="generateGlossaryButton" class="secondary">Generate Glossary from Input</button>
          </div>
          <div style="display:flex; gap:0.5rem; margin-bottom:1rem; flex-wrap:wrap;">
            <div style="flex:1; min-width:150px;">
              <label for="newTerm">Chinese Term</label>
              <input type="text" id="newTerm" placeholder="Chinese term">
            </div>
            <div style="flex:1; min-width:150px;">
              <label for="newTranslation">Translation</label>
              <input type="text" id="newTranslation" placeholder="Translation">
            </div>
            <div style="flex:1; min-width:150px;">
              <label for="newCategory">Category</label>
              <input type="text" id="newCategory" placeholder="Category">
            </div>
            <div>
              <button id="addOrUpdateGlossaryButton">Add/Update</button>
            </div>
          </div>
          <label for="searchGlossary">Search Glossary:</label>
          <input
            type="text"
            id="searchGlossary"
            placeholder="Search glossary..."
            style="margin-bottom:1rem; width:100%;"
          >
          <div class="glossary-list">
            <table>
              <thead>
                <tr>
                  <th>Term</th>
                  <th>Translation</th>
                  <th>Format</th>
                  <th>Category</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody id="glossaryTable"></tbody>
            </table>
          </div>
          <div style="margin-top:1rem;">
            <button id="importGlossaryButton" class="secondary">Import Glossary</button>
            <button id="exportGlossaryButton">Export Glossary</button>
            <input type="file" id="importGlossaryFile" style="display:none" accept=".json">
          </div>
          <div style="margin-top:1rem;">
            <button id="themeToggleButton" class="secondary">Toggle Dark Mode</button>
          </div>
        </div>
      </section>
    </div>
  </div>

  <script>
    /* ================================
       =========== GLOBALS ============
       ================================ */
    const BACKEND_URL = "http://localhost:3000"; // or your deployed server
    let openRouterApiKey = localStorage.getItem("openRouterApiKey") || "";

    // Hardcoded sample glossary
    let glossary = {
      "五条悟": { translation: "Gojo Satoru", format: "off", category: "character" },
      "电次": { translation: "Denji", format: "off", category: "character" },
      // ... You can add more or load from localStorage
    };

    /* ================ DOM Elements ================ */
    const inputTextEl      = document.getElementById("inputText");
    const translatedTextEl = document.getElementById("translatedText");
    const charCountEl      = document.getElementById("charCount");
    const loadingIndicator = document.getElementById("loadingIndicator");
    const progressBarContainer = document.getElementById("progressBarContainer");
    const progressBarEl    = document.getElementById("progressBar");
    const docxFileInput    = document.getElementById("docxFileInput");

    /* ================ On Load ================ */
    document.getElementById("apiKeyInput").value = openRouterApiKey;
    window.addEventListener("DOMContentLoaded", () => {
      // Merge any previously stored glossary
      const storedGlossary = localStorage.getItem("glossary");
      if (storedGlossary) {
        try {
          glossary = { ...glossary, ...JSON.parse(storedGlossary) };
        } catch {}
      }
      renderGlossaryList();
      updateCharCount();

      // Load saved notes
      document.getElementById("customNotes").value = localStorage.getItem("customNotes") || "";
    });

    /* ================================
       ====== API KEY MANAGEMENT ======
       ================================ */
    document.getElementById("saveApiKeyButton").addEventListener("click", () => {
      const keyInput = document.getElementById("apiKeyInput").value.trim();
      if (keyInput) {
        openRouterApiKey = keyInput;
        localStorage.setItem("openRouterApiKey", keyInput);
        document.getElementById("apiKeyStatus").textContent = "API Key saved!";
        document.getElementById("apiKeyStatus").style.color = "green";
      } else {
        document.getElementById("apiKeyStatus").textContent = "Enter a valid key!";
        document.getElementById("apiKeyStatus").style.color = "red";
      }
    });

    /* ================================
       === PERSISTENT NOTES (CONTEXT) ==
       ================================ */
    document.getElementById("saveNotesButton").addEventListener("click", () => {
      const notes = document.getElementById("customNotes").value.trim();
      localStorage.setItem("customNotes", notes);
      alert("Notes saved!");
    });
    document.getElementById("clearNotesButton").addEventListener("click", () => {
      document.getElementById("customNotes").value = "";
      localStorage.removeItem("customNotes");
    });
    function getCustomPrompt() {
      const useNotes = document.getElementById("useNotesCheckbox").checked;
      const notes = localStorage.getItem("customNotes") || "";
      if (!useNotes || !notes) return "";
      // Build a basic "system" style context
      return `You are translating a novel or fanfiction. ${notes}`;
    }

    /* ================================
       ====== GLOSSARY MANAGEMENT =====
       ================================ */
    function saveGlossary() {
      localStorage.setItem("glossary", JSON.stringify(glossary));
    }
    function renderGlossaryList(filtered = null) {
      const glossaryTable = document.getElementById("glossaryTable");
      glossaryTable.innerHTML = "";
      const dataSource = filtered || glossary;
      for (const [term, entry] of Object.entries(dataSource)) {
        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${term}</td>
          <td>${entry.translation}</td>
          <td>
            <button onclick="toggleFormat('${term}')">
              ${entry.format.charAt(0).toUpperCase() + entry.format.slice(1)}
            </button>
          </td>
          <td>${entry.category || ""}</td>
          <td>
            <button onclick="editGlossaryTerm('${term}')">Edit</button>
            <button onclick="deleteGlossaryTerm('${term}')">Delete</button>
          </td>
        `;
        glossaryTable.appendChild(row);
      }
    }
    window.toggleFormat = function(term) {
      const formats = ["off", "bold", "italic"];
      const current = glossary[term].format;
      const next = formats[(formats.indexOf(current) + 1) % formats.length];
      glossary[term].format = next;
      saveGlossary();
      renderGlossaryList();
    };
    window.editGlossaryTerm = function(term) {
      document.getElementById("newTerm").value = term;
      document.getElementById("newTranslation").value = glossary[term].translation;
      document.getElementById("newCategory").value = glossary[term].category || "";
    };
    window.deleteGlossaryTerm = function(term) {
      delete glossary[term];
      saveGlossary();
      renderGlossaryList();
    }
    document.getElementById("addOrUpdateGlossaryButton").addEventListener("click", () => {
      const t = document.getElementById("newTerm").value.trim();
      const tr = document.getElementById("newTranslation").value.trim();
      const c = document.getElementById("newCategory").value.trim();
      if (t && tr) {
        if (!glossary[t]) {
          glossary[t] = { translation: tr, format: "off", category: c };
        } else {
          glossary[t].translation = tr;
          glossary[t].category = c;
        }
        saveGlossary();
        renderGlossaryList();
        document.getElementById("newTerm").value = "";
        document.getElementById("newTranslation").value = "";
        document.getElementById("newCategory").value = "";
      } else {
        alert("Please fill in term and translation!");
      }
    });
    document.getElementById("searchGlossary").addEventListener("input", (e) => {
      const val = e.target.value.toLowerCase();
      const filtered = {};
      for (const [term, entry] of Object.entries(glossary)) {
        if (term.toLowerCase().includes(val) ||
            entry.translation.toLowerCase().includes(val) ||
            (entry.category || "").toLowerCase().includes(val)) {
          filtered[term] = entry;
        }
      }
      renderGlossaryList(filtered);
    });
    // Import/Export
    document.getElementById("importGlossaryButton").addEventListener("click", () => {
      document.getElementById("importGlossaryFile").click();
    });
    document.getElementById("importGlossaryFile").addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = evt => {
        try {
          const imported = JSON.parse(evt.target.result);
          glossary = { ...glossary, ...imported };
          saveGlossary();
          renderGlossaryList();
        } catch (err) {
          alert("Invalid JSON");
        }
      };
      reader.readAsText(file);
    });
    document.getElementById("exportGlossaryButton").addEventListener("click", () => {
      const blob = new Blob([JSON.stringify(glossary, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "glossary.json";
      a.click();
    });
    document.getElementById("generateGlossaryButton").addEventListener("click", () => {
      alert("Placeholder: Implement AI-based glossary generation if desired.");
    });

    /* ================================
       === GLOSSARY PRE-REPLACEMENT ===
       ================================ */
    document.getElementById("preReplaceButton").addEventListener("click", () => {
      let original = inputTextEl.value;
      if (!original.trim()) {
        alert("Please enter text first!");
        return;
      }
      let replaced = original;
      for (const [term, data] of Object.entries(glossary)) {
        if (!term) continue;
        const safeTerm = term.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        const regex = new RegExp(safeTerm, "g");
        replaced = replaced.replace(regex, () => {
          if (data.format === "bold") return `<b>${data.translation}</b>`;
          if (data.format === "italic") return `<i>${data.translation}</i>`;
          return data.translation;
        });
      }
      inputTextEl.value = replaced;
      updateCharCount();
      alert("Glossary terms replaced in input text.");
    });

    /* ================================
       === DOCX UPLOAD HANDLING ======
       ================================ */
    document.getElementById("uploadDocxButton").addEventListener("click", () => {
      docxFileInput.click();
    });
    docxFileInput.addEventListener("change", async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      if (!openRouterApiKey) {
        alert("Please set your API key first.");
        return;
      }
      try {
        const formData = new FormData();
        formData.append("file", file);
        const response = await fetch(`${BACKEND_URL}/upload-docx`, {
          method: "POST",
          body: formData
        });
        if (!response.ok) throw new Error("Upload or extraction failed");
        const data = await response.json();
        inputTextEl.value = data.text;
        updateCharCount();
      } catch (err) {
        alert("Error reading .docx file.");
      }
    });

    /* ================================
       ======== TRANSLATION FLOW ======
       ================================ */
    document.getElementById("clearInputButton").addEventListener("click", () => {
      inputTextEl.value = "";
      updateCharCount();
    });
    document.getElementById("clearOutputButton").addEventListener("click", () => {
      translatedTextEl.value = "";
    });

    // Real-time translation with small delay
    let typingTimer;
    const realtimeDelay = 1000;
    inputTextEl.addEventListener("input", () => {
      updateCharCount();
      const realtimeCheckbox = document.getElementById("realtimeCheckbox");
      if (!realtimeCheckbox.checked) return;
      clearTimeout(typingTimer);
      typingTimer = setTimeout(() => {
        performTranslation();
      }, realtimeDelay);
    });

    // Manual translation
    document.getElementById("translateButton").addEventListener("click", () => {
      performTranslation();
    });

    async function performTranslation() {
      const text = inputTextEl.value.trim();
      const targetLanguage = document.getElementById("targetLanguage").value;
      if (!text) {
        alert("Please enter text to translate!");
        return;
      }
      if (!openRouterApiKey) {
        alert("Please set your API key first.");
        return;
      }
      startProgress();
      loadingIndicator.style.display = "block";
      const userNotes = getCustomPrompt();

      try {
        // Optionally chunk the text if it's too long
        const chunkedResult = await translateLargeText(text, targetLanguage, userNotes);
        translatedTextEl.value = chunkedResult;
      } catch (error) {
        console.error(error);
        alert("Translation error occurred.");
      } finally {
        loadingIndicator.style.display = "none";
        endProgress();
      }
    }

    // Example chunking approach
    async function translateLargeText(fullText, targetLanguage, customNotes = "") {
      const chunkSize = 4000; // ~4000 chars, can adjust for tokens
      let start = 0;
      let finalOutput = "";
      while (start < fullText.length) {
        const chunk = fullText.slice(start, start + chunkSize);
        const translatedChunk = await fetch(`${BACKEND_URL}/translate`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            apiKey: openRouterApiKey,
            text: chunk,
            targetLanguage: targetLanguage,
            glossary,
            customNotes
          })
        }).then(r => r.json());
        if (translatedChunk.error) throw new Error(translatedChunk.error);
        finalOutput += translatedChunk.translatedText;
        start += chunkSize;
      }
      return finalOutput;
    }

    /* ================================
       ====== EXPORT FUNCTIONS =======
       ================================ */
    document.getElementById("exportTxtButton").addEventListener("click", () => {
      const text = translatedTextEl.value;
      const blob = new Blob([text], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "translation.txt";
      a.click();
    });
    document.getElementById("exportHtmlButton").addEventListener("click", () => {
      const text = translatedTextEl.value;
      const blob = new Blob([text], { type: "text/html" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "translation.html";
      a.click();
    });

    /* ================================
       ======= THEME TOGGLE ==========
       ================================ */
    document.getElementById("themeToggleButton").addEventListener("click", () => {
      document.body.classList.toggle("dark-mode");
    });

    /* ================================
       == COLLAPSIBLE GLOSSARY PANEL ==
       ================================ */
    const glossaryPanel = document.getElementById("glossaryPanel");
    const toggleGlossaryBtn = document.getElementById("toggleGlossaryPanel");
    toggleGlossaryBtn.addEventListener("click", () => {
      if (glossaryPanel.classList.contains("collapsed")) {
        glossaryPanel.classList.remove("collapsed");
        toggleGlossaryBtn.textContent = "Hide";
      } else {
        glossaryPanel.classList.add("collapsed");
        toggleGlossaryBtn.textContent = "Show";
      }
    });

    /* ================================
       === CHARACTER/TOKEN COUNTS ====
       ================================ */
    function updateCharCount() {
      const text = inputTextEl.value;
      const charCount = text.length;
      const approxTokens = text.trim() ? text.split(/\s+|\p{P}+/u).filter(Boolean).length : 0;
      charCountEl.textContent = `Characters: ${charCount} | Approx. Tokens: ${approxTokens}`;
    }

    /* ================================
       ==== PROGRESS BAR HELPERS =====
       ================================ */
    let progressInterval;
    function startProgress() {
      progressBarContainer.style.display = "block";
      progressBarEl.style.width = "0%";
      let width = 0;
      progressInterval = setInterval(() => {
        if (width >= 90) {
          clearInterval(progressInterval);
        } else {
          width += 3;
          progressBarEl.style.width = width + "%";
        }
      }, 200);
    }
    function endProgress() {
      clearInterval(progressInterval);
      progressBarEl.style.width = "100%";
      setTimeout(() => {
        progressBarContainer.style.display = "none";
      }, 500);
    }
  </script>
</body>
</html>
